# Tutorial for guard insertion and removal

An HLS translates a program dependence graph into an
architectural sketch in Chisel. The architectural sketch is a synthesizable description of the accelerator at the microarchitecture level.
Here is an example of [architecture description file] this file is an intermediate representation in the Chisel language.

Each operator node, which roughly corresponds to an operation/instruction in object code, has a [debug input flag. Line 145 declaration](https://anonymous.4open.science/r/muGrind-playground-BFFE/benchmarks/bbgemm.scala) which is set to either true or false at the beginning. When a debug flag for an operator is set to true the guard circuit will be built in during the FIRRTL (prior to final verilog) generation. The connections between the H-RTL pipeline register and wires to the guard operator is achieved through matching bore and sink pairs. We use the [boring utils framework](https://www.chisel-lang.org/api/latest/chisel3/util/experimental/BoringUtils$.html) to transform the FIRRTL and wire up any [H-RTL signal, line 131](https://anonymous.4open.science/r/muGrind-playground-BFFE/benchmarks/HLSComputeOperator.scala) to the guard ports with matching names[line 48-51](https://anonymous.4open.science/r/muGrind-playground-BFFE/benchmarks/GuardComputeOperator.scala). The chisel itself has to only specify a name for the ports; this naming is automatically generated by the HLS compiler.

To help the HLS compiler easily specify where to build in the guard circuit we define a [json api](https://anonymous.4open.science/r/muGrind-playground-BFFE/benchmarks/bbgem_config.json). This file contains.

- **NumDBGs** the number of operators being guarded. Helps with resource calculation and trimming based on how much BRAM is left in design.
- **boreIDs**: the unqie IDs that map between HLS compiler representation, software, and RTL statements. The HLS compiler generates the IDs and ugrind auto-generates this set.
- **dataLen**: Width of data lines from the H-RTL operator to guard.

## To remove guards

The designer can also intervene and modify the json file (although they are not required to).
Simply specify `boreIDs` set and `NumDBGs` to 0. FIRRTL will rip out any connections between the [H-RTL node (line 130: `if (Debug)`](https://anonymous.4open.science/r/muGrind-playground-BFFE/benchmarks/HLSComputeOperator.scala) and guards and FIRRTL [dead-code elimination](https://github.com/chipsalliance/firrtl/blob/master/src/main/scala/firrtl/transforms/DeadCodeElimination.scala) will remove all the guard circuits and associated logic since they are not connected to main design.

```scala
  // Conditional verilog generation of Guard logic.
  // If flag is false; guards left unconnected and is dead code
  // Gets eliminated during final verilog generation.
  if (Debug) {
    // Specify soft connects that FIRRTL turns into wires during verilog generation. Corresponding sinks
 BoringUtils.addSink(in_log_value, s"in_log_data${ID}")
    BoringUtils.addSink(in_log_value_valid, s"in_log_Buffer_valid${ID}")
   ......
   // Dynamic guard activation. Guard circuit gets built in but can be deactivated/activated during execution.
    test_value_valid := enable_valid_R && !(state === s_COMPUTE)
  }
```
